<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>Problems and Troubleshooting: GBDK</title>
  </head>

  <body BGCOLOR="#C0C0FF" LINK="#CC0000" VLINK="#333333" ALINK="#333333" TEXT="#330000">
    <FONT FACE="Arial,Helvetica" SIZE="-1">
    <h1>Problems and Troubleshooting: GBDK</h1>
<H2><A NAME="Troubleshooting"></A>Troubleshooting</H2>

<H2>Assembly Errors</H2>

<P>
Messages of the type:
</P>
<PRE>
    u 0226
    a 0329
    u 0333
</PRE>

<P>
are error messages from the assembler. To see where these errors occur, you should produce an assembly listing using the <CODE>-Wa-l</CODE> flag of lcc and have a look at this file. If such an error occurs with a file generated by the compiler, send me the C source along with the listing.
</P>
<p>The assembler in GBDK 2.0.18 and later produces emacs next-error format messages like
</p>
<pre>
silly.s:5: Error: <o> .org in REL area or directive / mnemonic error
</pre>
<p>This means that ther is an error in silly.s at line five.
</p>

<H2>Link Errors</H2>

<P>
Messages of the type:
</P>
<PRE>
    ?ASlink-W-Undefined Global     .count referenced by module Demo
</PRE>

<P>
are error messages from the linker. An image file is generated, but sould be corrupted. Detailed information about errors can be found in map files (generated using the <CODE>-Wl-m</CODE> flag of lcc).
</P>

<H2>DOS Shell Errors</H2>

<P>
The DOS shell truncates commmand lines to something like 128 characters. If you have to use a longer line due to the number of flags you pass to the compiler, I strongly encourage you to get <CODE>bash</CODE>, a DOS port of Unix Bourne-Again SHell. It is much more powerful than DOS shell, and does not truncate command lines. A better alternative is to get <CODE>make</CODE>, a DOS port of the Unix make utility, and use makefiles instead of DOS batch files. Of course, you can get both. They are available as part of <A HREF="http://www.delorie.com/djgpp/">DJGPP</A> (DOS port of GNU C).
</P>

<!-- ############################################################ -->
<HR>

<H2><A NAME="Problems"></A>Known Problems</H2>

<H2>Known problems in GBDK 2.0</H2>

<UL>
	<LI>The maximum number of indexes for an array is 127. This is due to the fact that lcc uses integer values for array indexes. This does not affect statically-initialized arrays like:
<PRE>
    UBYTE tiles[] = { 0x00, 0x01, ..., 0xFF };
</PRE>
	But declaring the following arrays cause a compiler error:
<PRE>
    UBYTE tiles[128];
</PRE>
	Here is the answer sent to me by Dave Hanson, one of the authors of lcc:
<P>
<CITE>
This is actually the most serious problem. ANSI C stipulates 32Kb as the maximum size of any object. lcc does indeed assume that an int can hold 16-bit values, because it uses ints to hold sizes (e.g., in type structures). Accepting long array sizes would be no problem, and it would work OK as long as the machine on which lcc runs has 16-bit ints. But changing "int" to "long" for every variable/field that holds a size would be painful and would involve touching every module.
</CITE>
</P>
	A workaround for this problem is to declare multiple-dimensions arrays, and to use them as single-dimension arrays:
<PRE>
	UBYTE tiles[64][8]; /* This declares an array of 64*8 = 512 unsigned bytes */

	void foo() {
	  UWORD l;
	  ((UBYTE *)tiles)[500] = 0;
	  l = 500;
	  ((UBYTE *)tiles)[l] = 0;
	}
</PRE>
	<LI>The code generator might crash when working with programs that contain very complex expressions.
</UL>


<!-- begin footer -->
    <hr>
    <a href="default.htm">Back</a>
    <address><a href="mailto:michaelh@juju.net.nz">Michael Hope</a></address>
<!-- end footer -->
<!-- Created: Mon May 10 20:16:59 NZST 1999 -->
<!-- hhmts start -->
Last modified: Mon May 10 21:43:47 NZST 1999
<!-- hhmts end -->
	</FONT>
  </body>
</html>
